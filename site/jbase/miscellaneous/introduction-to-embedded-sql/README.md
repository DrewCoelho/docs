# Introduction to EmBedded SQL

**Created At:** 3/13/2017 6:46:27 PM  
**Updated At:** 1/3/2018 2:36:31 PM  
**Original Doc:** [introduction-to-embedded-sql](https://docs.jbase.com/30312-jagent/introduction-to-embedded-sql)  
**Original ID:** 230068  
**Internal:** Yes  

## Synopsis

Embedded SQL is a method of combining the computing power of a programming language and the database manipulation capabilities of SQL. Embedded SQL statements are SQL statements written inline with the program source code of the host language. The embedded SQL statements are parsed by an embedded SQL preprocessor and replaced by host-language calls to a code library. The output from the preprocessor is then compiled by the host compiler. This allows programmers to embed SQL statements in programs written in any number of languages such as C/C++, COBOL and Fortran. This differs from SQL-derived programming languages that don't go through discrete preprocessors, such as PL/SQL and T-SQL.

### Why it has been updated

Added simply because the original version of [Nsqlprep] . . . - has not been supported since SQL server 2005 - even if it worked, nsqlpreps libraries are 32 bit only - We have claimed to support it since 2000 and jBASE 3.x

### Things left to do

Currently we build on centos5, Microsoft don’t release their libraries for Linux until Centos6, hopefully providing there are no unforeseen issues we should also be able to add the same functionality for Linux.  
The first version is as bare bones as they come,  it has minimal support for SQL and will only be updated if needed.

### What benefits does it bring

Using modern versions of the olddb libraries allows jBASE to connect to a database using almost any valid connection string,   Provides a simple syntax that should allow any jBC programmer to import/export data to different databases from a simple jBC program.  This can be achieved by using ESQL or calling the new JBC functions directly.

### How does it impact existing functionality

Because there was previously nothing working on MS platforms for 5.x, these changes should have zero impact.  However, because there was already support built into jBASE for other flavours of ESQL on various platforms we have to work around the existing mechanism.

## Existing Mechanism overview

Currently jcompile will do some of the pre-processing before invoking ESQL compile, for example if you were to do..

- jcompile -Jqm mytest.b

jBASE will generate

- mytest.j                        generic jbase header containing variable structures, includes etc…
- mytest.k                        C representation of the DECLARE section for mytest.b
- [mytest.sqc](mytest.sqc)        normal compile to C jBC code with the additional [EXEC SQL] commands.

Jesqlprep, will attempt to parse mytest.sqc, and add in any call to [libJBCESQL] to run the embedded SQL commands.

## SYSTEM(0)

The status of any command will be saved into SYSTEM(0),  SYSTEM(0) does nothing more than return a flag from dp,  this can also be overwritten by any other jBASE function that goes wrong so its not to be relied on unless checked immediately after running a SQL statement.

## Esql components

- Nsqlprep        &gt;&gt;        calls jesqlprep
- Jesqlprep       &gt;&gt;        fills in missing bits for C code and SQL, (limited syntax)
- [libESQL.dll](libESQL.dll)     &gt;&gt;         odbc/oledb wrapper
- [libJBCESQL.dll](libJBCESQL.dll)  &gt;&gt;      jbc wrapper for [libESQL.dll](libESQL.dll)

### Nsqlprep

Added for backward compatibility, should do nothing more than call jesqlprep passing in the name on the .sqc file generated by jcompile.

At some point I’ll have to parse whats passed in and strip any unneeded options.

### Jesqlprep

Parses the .sqc file and replaces any embedded SQL commands with their C equivalents.

For example,

- ESQL CONNECT :Database

Should be replaced with some C code to connect to a database passing in the value stored in jBC variable [:Database] as the connection string.

### libESQL.dll

New c++ class that wraps the ODBC/OLEDB libraries to make life easy for us.

### libJBCESQL.dll

Interface of jBC functions to carry out generic operations from jBC.

Because jBASE is compiled in [C], we need some form of interface that will let us access external libraries and return data back to the users BASIC code.

## Common terms used in document

?What is a result set?

- Think of a result set as a huge big list of records stored in an array.

? What is a cursor,

- a cursor enables the rows in a result set to be processed sequentially.

```
  . Row     Data
  . 1  a]b]c]d 2  a]b]c]d
 >> 3    a]b]c]d
  . 4  a]b]c]d
```

Just like in jBASE when you say READNEXT,  the cursor moves to the next item in the list.

## ESQL Commands

### Non-standard verbs

The following are verbs that nsqlprep will look for in your jBC code, they are generally the first token to follow [EXEC SQL].

Additional commands have been added to help support new driver:

#### AUTOCOMMIT #1

OLDEB will have auto commit set by default, no good if you want to control when you commit somthing and check for issues.

#### ERRORMESSAGE #1

jBASE variable to store last error message in, useful for diagnostics.

### AUTOCOMMIT #2

Added so we can turn off auto commit, by default its always on which can be an issue.

Options: ON/OFF

### BEGIN/END

Used to define some form of link between a jBASE variables and SQL variables.

e.g.

```
 EXEC SQL BEGIN DECLARE SECTION; INT PartNo; STRING(20) PartName; STRING(20) Database; EXEC SQL END DECLARE SECTION;
 EXEC SQL DECLARE cursorbacs CURSOR FOR SELECT PartNo, PartName FROM Parts;
 . . .
 EXEC SQL FETCH cursorbacs INTO :PartNo, :PartName;
 . . .
 CRT PartNo, PartName
```

In this example, the table Parts is selected returning values for the columns PartNo, PartName.

Each subsequent call to [FETCH] will then populate the jBC variables PartNo, PartName.

### CLOSE

Closes a cursor. (active statement)

```
EXEC SQL CLOSE cursorbacs;
```

### COMMIT

Causes any data in the current connection to be written to the database, just now it writes and closes any opened cursors.

We also ignore WORK/HOLD as there not currently supported,  COMMIT should commit any changes and close the current statement.

```
EXEC SQL COMMIT WORK HOLD
EXEC SQL COMMIT WORK has the same effect as COMMIT.
EXEC SQL COMMIT HOLD Dont kill cursor on error.
```

### CONNECT

Connects to a database using a connection string, this can be an SQL server style url or a DSN.

E,g.

```
Database = 'Driver={SQL Server Native Client 11.0}; Server=localhost\SQLEXPRESS; Database=Northwind; Trusted_Connection=yes; ID=.\localuser; Password=password'
EXEC SQL CONNECT :Database;
```

Or a DSN equivalent.

```
Database = 'DSN=accounts'
EXEC SQL CONNECT :Database;
```

Or even just hard codes.

```
EXEC SQL CONNECT DSN=hardcoded;
```

The connection string is nothing more than ASCII text, you can store them in your jBC program or read them from a file,

### CONTROL

```
 . No idea
}}

=== CREATE ===

Create a new table, syntax may vary depending on the database you connect to, its generic form is…

{{{
EXEC SQL CREATE TABLE Parts (PartNo INTEGER NOT NULL, PartName VARCHAR(20),PRIMARY KEY (PartName));
```

### DECLARE

Define the statement you are going to use to get the data from SQL, its more or less like doing a jBASE select, then reading in the data in a loop after the query has finished.

```
EXEC SQL DECLARE cursorbacs CURSOR FOR SELECT PartNo, PartName FROM Parts;
```

(see fetch)

### DELETE

Deletes records from a SQL database.

```
 . EXEC SQL DELETE FROM Parts WHERE PartNo=:PartNo;
```

### DISCONNECT

Shuts down the current connection.

```
EXEC SQL DISCONNECT;
```

### DROP

Delete a table, (just like running DELETE-FILE)

```
EXEC SQL DROP TABLE :table_name; EXEC SQL DROP Partsa;
```

### ERRORMESSAGE #2

Hold any messages returned from ESQL in a jBASE VAR.

```
EXEC SQL WHENEVER SQLERROR GOTO proglab_SqlError;
. . .
EXEC SQL ERRORMESSAGE ESQLErrorMessage;
. . .
SqlError:
CRT "ESQLErrorMessage [":ESQLErrorMessage:"]" RETURN
```

Store last error message in [ESQLErrorMessage]

### FETCH

Reads a row from a SQL database,

```
 . EXEC SQL FETCH cursorsdtrans INTO :type, :dramount, :cramount;
```

### INCLUDE

```
 . No idea
```

### INSERT

Inserts a new record in to a SQL database.

```
EXEC SQL [REPEATED] INSERT INTO table_name (column {, column}) VALUES (expr{, expr}) {,(expr{, expr} )
EXEC SQL INSERT INTO Parts (PartNo, PartName) VALUES (:PartNo, :PartName );
EXEC SQL INSERT INTO Parts VALUES (:PartNo, :PartName );
```

- We don’t support REPEATED

Currently we only support a single record at a time.

### OPEN

Causes the statement associated with the cursor name to be executed.

```
 . EXEC SQL OPEN cursorbacs FOR READONLY;
```

- Only use the cursor name.

e.g.

```
EXEC SQL DECLARE cursorbacs CURSOR FOR SELECT PartNo, PartName FROM Parts;
. . .
EXEC SQL OPEN cursorbacs;
. . .
LOOP
    EXEC SQL FETCH cursorbacs INTO :PartNo, :PartName; . . .
UNTIL no_more_data DO REPEAT
. . .
```

[OPEN] will triggered, [SELECT PartNo, PartName  FROM Parts;] to be ran on the SQL database.

### SELECT

```
EXEC SQL SELECT * INTO :record FROM emp
}}

Depending on the implementation it will copy from one table to another or return all values into a jbc VAR.

We currently only support copying from one table to another.

{{{
EXEC SQL SELECT ename, empno INTO :name,:number FROM emp WHERE a=:b ORDER BY :ord;
```

- Not currently supported, use FETCH,

### ROLLBACK

Cancel any updates sent to the SQL database within the current session/connection.

```
EXEC SQL ROLLBACK WORK ;
```

Just like with [COMMIT], [WORK]/[HOLD] are ignored.

### UPDATE

Updates an existing record in the SQL database.

EXEC SQL UPDATE emp SET sal = :salary, comm = :commission WHERE empno = :emp\_number;

### WORK

- No idea, not supported.

found this example,

```
BEGIN WORK;

 . LOCK TABLE stock; UPDATE stock SET unit_price = unit_price * 1.10
  . WHERE manu_code = 'KAR';
 DELETE FROM stock WHERE description = 'baseball bat'; INSERT INTO manufact (manu_code, manu_name, lead_time)
  . VALUES ('LYM', 'LYMAN', 14);

COMMIT WORK;
```

Guessing, looking at the example it’s the equivalent to saying BEGIN TRANS/ END TRANS.

Currently all updates SHOULD be in a default transaction via ODBC, will need to me verified.

### WHENEVER

Define what label in jBC to GOTO when something goes wrong,

E.g.

```
EXEC SQL WHENEVER SQLERROR GOTO proglab_SqlError;
EXEC SQL WHENEVER SQLWARNING GOTO proglab_SqlWarning;
EXEC SQL WHENEVER NOT FOUND GOTO proglab_NotFound;
```

## JBC API’s

Part of the updated MS ESQL interface is to expose the APIs we use in ESQL to jBC, ESQL is not for everyone and can make your programs unreadable.

Currently accessible functions are as follows.

- DEFC INT get\_connection\_object(VAR, VAR)
- DEFC INT get\_is\_connected(VAR)
- DEFC STRING get\_dsn\_string(VAR)
- DEFC INT get\_statement\_object(VAR, VAR)
- DEFC INT statement\_execute\_query(VAR, VAR)
- DEFC INT statement\_get\_column\_count(VAR)
- DEFC INT statement\_fetch\_first(VAR)
- DEFC INT statement\_fetch\_last(VAR)
- DEFC INT statement\_fetch\_previous(VAR)
- DEFC INT statement\_fetch\_next(VAR)
- DEFC VAR statement\_fetch\_data(VAR)
- DEFC VAR statement\_fetch\_describe(VAR, VAR)
- DEFC VAR connection\_last\_error(VAR)
- DEFC VAR statement\_last\_error(VAR)
- DEFC INT connection\_enable\_auto\_commit(VAR)
- DEFC INT connection\_disable\_auto\_commit(VAR)
- DEFC INT connection\_status\_auto\_commit(VAR)

\* INT functions should return 1 for success and 0 for a fail.  \* VAR/STRING functions should return NULL strings when things fail.

### get\_connection\_object

connects to a datasource and returns the connection as a jBASE VAR.

e.g.

```
dsn = Database = 'Driver={SQL Server Native Client 11.0}; Server=localhost\SQLEXPRESS; Database=Northwind; Trusted_Connection=yes; ID=.\localuser; Password=password'
rc = get_connection_object(connection, dsn)
```

### get\_connection\_object\_login

Identical to get\_connection\_object but also accepts user name and password.

### get\_is\_connected

Checks if the current connection object is a valid connection object.

e.g.

```
IF get_is_connected(connection) ELSE CRT "Not connected...." ; STOP
```

### connection\_last\_error

returns the last error in a readable format.

e.g.

```
statement_status = get_statement_object(connection, current_statement)
IF statement_status = 0 THEN CRT connection_last_error(connection) ;
STOP
```

### statement\_last\_error

Similar to connection\_last\_error, will returns the last error in a readable format. But is based on the current statement.

e.g.

```
rc = statement_execute_query(current_statement, command)
IF rc NE 1 THEN  CRT "Error in statement [" : state-ment_last_error(current_statement) : "]"
```

### connection\_commit

Commits any outstanding updates on the server.

e.g.

```
Result = connection_commit(connection)
```

### connection\_rollback

drops any outstanding commits on the server.

e.g.

```
Result = connection_rolback(connection)
```

### get\_dsn\_string

Gets the connection string from an active connection.

e.g.

```
z = get_dsn_string(connection) CRT z
```

### get\_statement\_object

Creates a new statement object to run SQL statement with, needs an active connection.

e.g.

```
statement_status = get_statement_object(connection, current_statement)
```

### statement\_execute\_query

Executes a SQL statement,

e.g.

```
cmd = "INSERT INTO Parts (PartNo, PartName) VALUES (1, 'beer');"
rc = statement_execute_query(current_statement, cmd)
```

cmd can be any valid SQL statement.

### statement\_get\_column\_count

Counts the number of columns in the current results set.

e.g.

```
command = "SELECT TOP 10000 * FROM JCUSTOMERS"
rc = statement_execute_query(current_statement, command)
number_of_columns = statement_get_column_count(current_statement)
CRT "Results has [":number_of_columns:"] Columns."
```

### statement\_fetch\_first

Used to control the location of the cursor when data is returned from a select,

Resets the cursor to the first row in the current results set.

e.g.

```
 . rc = statement_fetch_first(current_statement)
```

### statement\_fetch\_previous

Used to control the location of the cursor when data is returned from a select,

Moves the cursor to point to the previous row in the current results set.

e.g.

```
rc = statement_fetch_previous(current_statement)
```

### statement\_fetch\_next

Used to control the location of the cursor when data is returned from a select,

Moves the cursor to point to the next row in the current results set.

e.g.

```
rc = statement_fetch_next(current_statement)
```

### statement\_fetch\_data

Reads the current record from an active select, use fetch\_prev/next to position the cur-sor.

e.g.

```
LOOP WHILE statement_fetch_next(current_statement)
   rec = statement_fetch_data(current_statement)
   id = rec<1>
   DEL rec<1>
   CRT "[":id:"][":rec:"]" "MCP"
REPEAT
```

Data is moved for SQL and created as a dynamic array, the sequence of the columns is de-fined by the order you select in.

e.g.

```
 . SELECT record_id, a, b, c FROM mytable
```

Will return a dynamic array in the following order.

```
 . record_id]a]b]c
```

for all records/rows stored in [mytable]

### statement\_fetch\_describe

Creates a default dictionary for each row in the current results set.

e.g.

```
number_of_columns = statement_get_column_count(current_statement)
CRT "Result has [":number_of_columns:"] Columns."
FOR x = 1 TO number_of_columns
  CRT statement_fetch_describe(x, current_statement) "MCP"
NEXT x
```

output:

```
Result has [2] Columns.
D^0^^PartNo^10L^S
D^1PartName^20L^S
```

Used in testing to match up imported data on jBASE.

### statement\_fetch\_column\_name

gets the name of a column from its row number.

e.g.

```
column_name = statement_fetch_column_name(1, current_statement)
```

### connection\_enable\_auto\_commit

Switches on auto commit,

```
rc = connection_enable_auto_commit(connection)
```

### connection\_disable\_auto\_commit

Switches off auto commit.

```
rc = connection_disable_auto_commit(connection)
```

### connection\_status\_auto\_commit

gets status of auto commit.

```
rc = connection_status_auto_commit(connection)
```

## Examples

To run,

- create an ODBC DSN called zumasys
- on server, create table called Parts, two columns PartNo, PartName
- Add some data

### Listing a file via ESQL

- Compile with,
- . jcompile -Jqm esql\_example.b to run, esql\_example

(taken from customer example)

```
EXEC SQL BEGIN DECLARE SECTION;
INT PartNo; STRING(20) PartName; STRING(20) Database;
EXEC SQL END DECLARE SECTION;
EXEC SQL WHENEVER SQLERROR GOTO proglab_SqlError;
EXEC SQL WHENEVER SQLWARNING GOTO proglab_SqlWarning;
EXEC SQL WHENEVER NOT FOUND GOTO proglab_NotFound;
EXEC SQL DECLARE cursorbacs CURSOR FOR SELECT PartNo, PartName FROM Parts;
ID = "unknown" ATTR.NO = 0
KEEP.LOOPING = "Y"
NEW.REC = ""
Database = "DSN=zumasys"
EXEC SQL CONNECT :Database;
EXEC SQL OPEN cursorbacs;
CRT "Connected to database " : Database
LOOP
    EXEC SQL FETCH cursorbacs INTO :PartNo, :PartName;
    ATTR.NO = ATTR.NO + 1
    NEW.REC<ATTR.NO> = PartNo : "/" : PartName
    CRT "part no/name : [" : NEW.REC<ATTR.NO> : "]"
UNTIL KEEP.LOOPING = "N" DO REPEAT
EXEC SQL COMMIT ;
RETURN

SqlError:
    CRT "Errro"
RETURN

SqlWarning:
    CRT "warn"
RETURN

NotFound:
    CRT "not"
RETURN
```

### Listing a file via jBC

Compile with,

- jcompile jbase\_sql\_example.b

to run,

- jbase\_sql\_example zumasys SELECT \* from Parts;

```
DEFC INT get_connection_object(VAR, VAR)
DEFC INT get_is_connected(VAR)
DEFC INT connection_last_error(VAR)
DEFC STRING get_dsn_string(VAR)
DEFC INT get_statement_object(VAR, VAR)
DEFC INT statement_execute_query(VAR, VAR)
DEFC INT statement_get_column_count(VAR)
DEFC INT statement_fetch_first(VAR)
DEFC INT statement_fetch_last(VAR)
DEFC INT statement_fetch_previous(VAR)
DEFC INT statement_fetch_next(VAR)
DEFC VAR statement_fetch_data(VAR)
DEFC VAR statement_fetch_describe(VAR, VAR)
command_line =  TRIM(@SENTENCE)
CRT "[":command_line:"]"
CHANGE " " TO @FM IN command_line
DEL command_line<1>
dsn = "DSN=":command_line<1>
DEL command_line<1>
command = command_line
CHANGE @FM TO " " IN command
CRT "[DSN=":dsn:"]"
CRT "[":command:"]"
connection = ""
rc = get_connection_object(connection, dsn)
z = get_dsn_string(connection)
current_statement = ""
statement_status = 0
IF get_is_connected(connection) ELSE CRT "Not connected...." ; STOP
statement_status = get_statement_object(connection, current_statement)
IF statement_status = 0 THEN CRT "Statment create failed", statement_status ; STOP
rc = statement_execute_query(current_statement, command)
number_of_columns = statement_get_column_count(current_statement)
CRT "Results has [":number_of_columns:"] Columns."
FOR x = 1 TO number_of_columns
    CRT statement_fetch_describe(x, current_statement) "MCP"
NEXT x
CRT cnt = 1
result = ""
LOOP WHILE statement_fetch_next(current_statement)
    result = statement_fetch_data(current_statement) "MCP"
    CRT cnt, "[":result:"]"
    cnt ++
REPEAT
```
